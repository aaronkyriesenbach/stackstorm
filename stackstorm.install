set -e

preinst() {
# summary of how this script can be called:
#        * <new-preinst> `install'
#        * <new-preinst> `install' <old-version>
#        * <new-preinst> `upgrade' <old-version>
#        * <old-preinst> `abort-upgrade' <new-version>
# for details, see http://www.debian.org/doc/debian-policy/ or
# the debian-policy package

PACKS_GROUP=st2packs
SYS_USER=stanley
ST2_USER=st2
ST2_CONFPATH="/etc/st2/st2.conf"
ST2_UPGRADESTAMP="/tmp/.stamp-stackstorm-st2-deb-package"

## Permissions of directories which has to be reset on upgrade
RESET_PERMS=$(cat <<EHD | sed 's/\s\+/ /g'
ug+rw root:_packsgroup /opt/stackstorm/packs
ug+rw root:_packsgroup /usr/share/doc/st2/examples
ug+rw root:_packsgroup /opt/stackstorm/virtualenvs
755 _st2user:root      /opt/stackstorm/configs
755 _st2user:root      /opt/stackstorm/exports
EHD
)

## Create stackstorm users and groups
create_users() {
  # create st2 user (services user)
  (id $ST2_USER 1>/dev/null 2>&1) ||
    useradd -U --no-create-home --system $ST2_USER

  # make st2 member of st2packs group
  (getent group $PACKS_GROUP 1>/dev/null 2>&1) || groupadd -r $PACKS_GROUP
  (groups $ST2_USER 2>/dev/null | grep -q "\b${PACKS_GROUP}\b") ||
    usermod -a -G $PACKS_GROUP $ST2_USER

  # create stanley user (for actionrunner service)
  if (! id $SYS_USER 1>/dev/null 2>&1); then
    useradd --disabled-password -c "" -U $SYS_USER
  fi
}

## [NOT USED!] Get current system user from the st2.conf
config_sysuser() {
  # exit hooked
  return 0
  local sysuser=
  if [ -f $ST2_CONFPATH ]; then
    sysuser=$(cat $ST2_CONFPATH |
      sed -n -e '/\[system_user\]/,/\[.*\]\|\$/ { /\[.*\]/d; /user\s*=/ { s/\s*user\s*=\s*//; p } }')
  fi
  echo $sysuser
}

## Update logrotate configuration
enable_logrotate() {
  [ -f /etc/logrotate.d/st2-pkgsaved.disabled ] &&
    mv -f /etc/logrotate.d/st2-pkgsaved.disabled /etc/logrotate.d/st2 || :
}

## Fix directories permissions on upgrade (different across maint scripts!)
#  NB! USED FOR COMPATIBILITY ON UPGRADE FROM PREVIOUS VERSIONS OF PACKAGES.
#  NB! In future package releases reseting permissions SHOULD BE REMOVED.
#
set_permissions() {
  local fileperms="$1" mode= ownership= path= current_ownership= user= group=

  echo "$fileperms" | sed -e "s/_packsgroup/$PACKS_GROUP/g" -e "s/_st2user/$ST2_USER/g" |
  while read mode ownership path; do
    user=$(echo $ownership | cut -f1 -d:)
    group=$(echo $ownership | cut -f2 -d:)
    # set top level permissions whether it's a file or directory
    [ -e $path ] || continue
    chown $ownership $path && chmod $mode $path

    # recursively change permissions of children (since those are directories)
    find $path -mindepth 1 -maxdepth 1 -not \( -user $user -group $group \) |
      xargs -I {} sh -c "echo chown -R $ownership {} && echo chmod -R $mode {}"
  done
}

case "$1" in
    install)
      create_users
      enable_logrotate
    ;;
    upgrade)
      create_users
      enable_logrotate
      set_permissions "$RESET_PERMS"
      touch $ST2_UPGRADESTAMP
    ;;
    abort-upgrade)
    ;;
    *)
        echo "preinst called with unknown argument \`$1'" >&2
        exit 1
    ;;
esac

# dh_installdeb will replace this with shell code automatically
# generated by other debhelper scripts.
}

postinst() {
# summary of how this script can be called:
#        * <postinst> `configure' <most-recently-configured-version>
#        * <old-postinst> `abort-upgrade' <new version>
#        * <conflictor's-postinst> `abort-remove' `in-favour' <package>
#          <new-version>
#        * <postinst> `abort-remove'
#        * <deconfigured's-postinst> `abort-deconfigure' `in-favour'
#          <failed-install-package> <version> `removing'
#          <conflicting-package> <version>
# for details, see http://www.debian.org/doc/debian-policy/ or
# the debian-policy package

ST2_USER=st2
PACKS_GROUP=st2packs
ST2_UPGRADESTAMP="/tmp/.stamp-stackstorm-st2-deb-package"
upgrading=0

## Permissions of files which should be set on install
SET_PERMS=$(cat <<EHD | sed 's/\s\+/ /g'
-R ug+rw root:_packsgroup /opt/stackstorm/packs
-R ug+rw root:_packsgroup /usr/share/doc/st2/examples
   ug+rw root:_packsgroup /opt/stackstorm/virtualenvs
   755 _st2user:root      /opt/stackstorm/configs
   755 _st2user:root      /opt/stackstorm/exports
   755 _st2user:root      /var/log/st2
   755 _st2user:root      /var/run/st2
   600 _st2user:_st2user  /etc/st2/htpasswd
EHD
)

## Fix directories permissions on install (different across maint scripts!)
set_permissions() {
  local fileperms="$1"
  fileperms=$(echo "$fileperms" | sed -e "s/_st2user/$ST2_USER/g" -e "s/_packsgroup/$PACKS_GROUP/g")
  # Reqursively chown given destinations!
  echo "$fileperms" | cut -f1,3,4 -d' ' | xargs -L1 chown
  # Set directories mode
  echo "$fileperms" | cut -f1,2,4 -d' ' | xargs -L1 chmod
}

# Choose first install or upgrade
[ -f $ST2_UPGRADESTAMP ] && upgrading=1 || :

case "$1" in
    configure)
      # Initially set destination files owenership (only on the first install)
      [ "$upgrading" = 1 ] || set_permissions "$SET_PERMS"
      rm -f $ST2_UPGRADESTAMP

      # make sure that our socket generators run
      systemctl daemon-reload >/dev/null 2>&1 || true
    ;;
    abort-upgrade|abort-remove|abort-deconfigure)
    ;;

    *)
        echo "postinst called with unknown argument \`$1'" >&2
        exit 1
    ;;
esac

# dh_installdeb will replace this with shell code automatically
# generated by other debhelper scripts.


# Automatically added by dh_python2:
# dh-virtualenv postinst autoscript
dh_venv_install_dir='/opt/stackstorm/st2'
dh_venv_package='st2'

# set to empty to enable verbose output
test "${DH_VERBOSE:-0}" = "1" && DH_VENV_DEBUG="" || DH_VENV_DEBUG=:
$DH_VENV_DEBUG set -x


dh_venv_safe_interpreter_update() {
    # get Python version used
    local pythonX_Y=$(cd "$dh_venv_install_dir/lib" && ls -1d python[2-9].*[0-9] | tail -n1)

    local i
    for i in python ${pythonX_Y%.*} ${pythonX_Y}; do
        local interpreter_path="$dh_venv_install_dir/bin/$i"

        # skip any symlinks, and make sure we have an existing target
        test ! -L "$interpreter_path" || continue
        test -x "$interpreter_path" || continue

        # skip if already identical
        if cmp "/usr/bin/$pythonX_Y" "$interpreter_path" >/dev/null 2>&1; then
            continue
        fi

        # hardlink or copy new interpreter
        cp -fpl "/usr/bin/$pythonX_Y" "$interpreter_path,new" \
            || cp -fp "/usr/bin/$pythonX_Y" "$interpreter_path,new" \
            || rm -f "$interpreter_path,new" \
            || true

        # make a backup (once)
        test -f "$interpreter_path,orig" || ln  "$interpreter_path" "$interpreter_path,orig"

        # atomic move
        if test -x "$interpreter_path,new" && mv "$interpreter_path,new" "$interpreter_path"; then
            echo "Successfully updated $interpreter_path"
        else
            echo >&2 "WARNING: Some error occured while updating $interpreter_path"
        fi
    done
}


case "$1" in
    configure|reconfigure)
        $DH_VENV_DEBUG echo "$0 $1 called with $# args:" "$@"
        dh_venv_safe_interpreter_update
        ;;

    triggered)
        $DH_VENV_DEBUG echo "$0 $1 called with $# args:" "$@"
        for trigger in $2; do
            case "$trigger" in
                /usr/bin/python?.*)
                    # this trigger might be for the "wrong" interpreter (other version),
                    # but the "cmp" in "dh_venv_safe_interpreter_update" and the fact we only
                    # ever look at our own Python version catches that
                    dh_venv_safe_interpreter_update
                    ;;
                dh-virtualenv-interpreter-update)
                    dh_venv_safe_interpreter_update
                    ;;
                *)
                    #echo >&2 "ERROR:" $(basename "$0") "called with unknown trigger '$2'"
                    #exit 1
                    ;;
            esac
        done
        ;;

    abort-upgrade|abort-remove|abort-deconfigure)
        ;;

    *)
        #echo >&2 "ERROR:" $(basename "$0") "called with unknown argument '$1'"
        #exit 1
        ;;
esac

$DH_VENV_DEBUG set +x
# END dh-virtualenv postinst autoscript

# End automatically added section
# Automatically added by dh_systemd_enable/12.10ubuntu1
if [ "$1" = "configure" ] || [ "$1" = "abort-upgrade" ] || [ "$1" = "abort-deconfigure" ] || [ "$1" = "abort-remove" ] ; then
	# This will only remove masks created by d-s-h on package removal.
	systemctl unmask 'st2actionrunner.service' >/dev/null || true

	# was-enabled defaults to true, so new installations run enable.
	if systemctl --quiet was-enabled 'st2actionrunner.service'; then
		# Enables the unit on first installation, creates new
		# symlinks on upgrades if the unit file has changed.
		systemctl enable 'st2actionrunner.service' >/dev/null || true
	else
		# Update the statefile to add new symlinks (if any), which need to be
		# cleaned up on purge. Also remove old symlinks.
		systemctl update-state 'st2actionrunner.service' >/dev/null || true
	fi
fi
# End automatically added section
# Automatically added by dh_systemd_enable/12.10ubuntu1
if [ "$1" = "configure" ] || [ "$1" = "abort-upgrade" ] || [ "$1" = "abort-deconfigure" ] || [ "$1" = "abort-remove" ] ; then
	# This will only remove masks created by d-s-h on package removal.
	systemctl unmask 'st2api.service' >/dev/null || true

	# was-enabled defaults to true, so new installations run enable.
	if systemctl --quiet was-enabled 'st2api.service'; then
		# Enables the unit on first installation, creates new
		# symlinks on upgrades if the unit file has changed.
		systemctl enable 'st2api.service' >/dev/null || true
	else
		# Update the statefile to add new symlinks (if any), which need to be
		# cleaned up on purge. Also remove old symlinks.
		systemctl update-state 'st2api.service' >/dev/null || true
	fi
fi
# End automatically added section
# Automatically added by dh_systemd_enable/12.10ubuntu1
if [ "$1" = "configure" ] || [ "$1" = "abort-upgrade" ] || [ "$1" = "abort-deconfigure" ] || [ "$1" = "abort-remove" ] ; then
	# This will only remove masks created by d-s-h on package removal.
	systemctl unmask 'st2stream.service' >/dev/null || true

	# was-enabled defaults to true, so new installations run enable.
	if systemctl --quiet was-enabled 'st2stream.service'; then
		# Enables the unit on first installation, creates new
		# symlinks on upgrades if the unit file has changed.
		systemctl enable 'st2stream.service' >/dev/null || true
	else
		# Update the statefile to add new symlinks (if any), which need to be
		# cleaned up on purge. Also remove old symlinks.
		systemctl update-state 'st2stream.service' >/dev/null || true
	fi
fi
# End automatically added section
# Automatically added by dh_systemd_enable/12.10ubuntu1
if [ "$1" = "configure" ] || [ "$1" = "abort-upgrade" ] || [ "$1" = "abort-deconfigure" ] || [ "$1" = "abort-remove" ] ; then
	# This will only remove masks created by d-s-h on package removal.
	systemctl unmask 'st2auth.service' >/dev/null || true

	# was-enabled defaults to true, so new installations run enable.
	if systemctl --quiet was-enabled 'st2auth.service'; then
		# Enables the unit on first installation, creates new
		# symlinks on upgrades if the unit file has changed.
		systemctl enable 'st2auth.service' >/dev/null || true
	else
		# Update the statefile to add new symlinks (if any), which need to be
		# cleaned up on purge. Also remove old symlinks.
		systemctl update-state 'st2auth.service' >/dev/null || true
	fi
fi
# End automatically added section
# Automatically added by dh_systemd_enable/12.10ubuntu1
if [ "$1" = "configure" ] || [ "$1" = "abort-upgrade" ] || [ "$1" = "abort-deconfigure" ] || [ "$1" = "abort-remove" ] ; then
	# This will only remove masks created by d-s-h on package removal.
	systemctl unmask 'st2notifier.service' >/dev/null || true

	# was-enabled defaults to true, so new installations run enable.
	if systemctl --quiet was-enabled 'st2notifier.service'; then
		# Enables the unit on first installation, creates new
		# symlinks on upgrades if the unit file has changed.
		systemctl enable 'st2notifier.service' >/dev/null || true
	else
		# Update the statefile to add new symlinks (if any), which need to be
		# cleaned up on purge. Also remove old symlinks.
		systemctl update-state 'st2notifier.service' >/dev/null || true
	fi
fi
# End automatically added section
# Automatically added by dh_systemd_enable/12.10ubuntu1
if [ "$1" = "configure" ] || [ "$1" = "abort-upgrade" ] || [ "$1" = "abort-deconfigure" ] || [ "$1" = "abort-remove" ] ; then
	# This will only remove masks created by d-s-h on package removal.
	systemctl unmask 'st2rulesengine.service' >/dev/null || true

	# was-enabled defaults to true, so new installations run enable.
	if systemctl --quiet was-enabled 'st2rulesengine.service'; then
		# Enables the unit on first installation, creates new
		# symlinks on upgrades if the unit file has changed.
		systemctl enable 'st2rulesengine.service' >/dev/null || true
	else
		# Update the statefile to add new symlinks (if any), which need to be
		# cleaned up on purge. Also remove old symlinks.
		systemctl update-state 'st2rulesengine.service' >/dev/null || true
	fi
fi
# End automatically added section
# Automatically added by dh_systemd_enable/12.10ubuntu1
if [ "$1" = "configure" ] || [ "$1" = "abort-upgrade" ] || [ "$1" = "abort-deconfigure" ] || [ "$1" = "abort-remove" ] ; then
	# This will only remove masks created by d-s-h on package removal.
	systemctl unmask 'st2sensorcontainer.service' >/dev/null || true

	# was-enabled defaults to true, so new installations run enable.
	if systemctl --quiet was-enabled 'st2sensorcontainer.service'; then
		# Enables the unit on first installation, creates new
		# symlinks on upgrades if the unit file has changed.
		systemctl enable 'st2sensorcontainer.service' >/dev/null || true
	else
		# Update the statefile to add new symlinks (if any), which need to be
		# cleaned up on purge. Also remove old symlinks.
		systemctl update-state 'st2sensorcontainer.service' >/dev/null || true
	fi
fi
# End automatically added section
# Automatically added by dh_systemd_enable/12.10ubuntu1
if [ "$1" = "configure" ] || [ "$1" = "abort-upgrade" ] || [ "$1" = "abort-deconfigure" ] || [ "$1" = "abort-remove" ] ; then
	# This will only remove masks created by d-s-h on package removal.
	systemctl unmask 'st2garbagecollector.service' >/dev/null || true

	# was-enabled defaults to true, so new installations run enable.
	if systemctl --quiet was-enabled 'st2garbagecollector.service'; then
		# Enables the unit on first installation, creates new
		# symlinks on upgrades if the unit file has changed.
		systemctl enable 'st2garbagecollector.service' >/dev/null || true
	else
		# Update the statefile to add new symlinks (if any), which need to be
		# cleaned up on purge. Also remove old symlinks.
		systemctl update-state 'st2garbagecollector.service' >/dev/null || true
	fi
fi
# End automatically added section
# Automatically added by dh_systemd_enable/12.10ubuntu1
if [ "$1" = "configure" ] || [ "$1" = "abort-upgrade" ] || [ "$1" = "abort-deconfigure" ] || [ "$1" = "abort-remove" ] ; then
	# This will only remove masks created by d-s-h on package removal.
	systemctl unmask 'st2timersengine.service' >/dev/null || true

	# was-enabled defaults to true, so new installations run enable.
	if systemctl --quiet was-enabled 'st2timersengine.service'; then
		# Enables the unit on first installation, creates new
		# symlinks on upgrades if the unit file has changed.
		systemctl enable 'st2timersengine.service' >/dev/null || true
	else
		# Update the statefile to add new symlinks (if any), which need to be
		# cleaned up on purge. Also remove old symlinks.
		systemctl update-state 'st2timersengine.service' >/dev/null || true
	fi
fi
# End automatically added section
# Automatically added by dh_systemd_enable/12.10ubuntu1
if [ "$1" = "configure" ] || [ "$1" = "abort-upgrade" ] || [ "$1" = "abort-deconfigure" ] || [ "$1" = "abort-remove" ] ; then
	# This will only remove masks created by d-s-h on package removal.
	systemctl unmask 'st2workflowengine.service' >/dev/null || true

	# was-enabled defaults to true, so new installations run enable.
	if systemctl --quiet was-enabled 'st2workflowengine.service'; then
		# Enables the unit on first installation, creates new
		# symlinks on upgrades if the unit file has changed.
		systemctl enable 'st2workflowengine.service' >/dev/null || true
	else
		# Update the statefile to add new symlinks (if any), which need to be
		# cleaned up on purge. Also remove old symlinks.
		systemctl update-state 'st2workflowengine.service' >/dev/null || true
	fi
fi
# End automatically added section
# Automatically added by dh_systemd_enable/12.10ubuntu1
if [ "$1" = "configure" ] || [ "$1" = "abort-upgrade" ] || [ "$1" = "abort-deconfigure" ] || [ "$1" = "abort-remove" ] ; then
	# This will only remove masks created by d-s-h on package removal.
	systemctl unmask 'st2scheduler.service' >/dev/null || true

	# was-enabled defaults to true, so new installations run enable.
	if systemctl --quiet was-enabled 'st2scheduler.service'; then
		# Enables the unit on first installation, creates new
		# symlinks on upgrades if the unit file has changed.
		systemctl enable 'st2scheduler.service' >/dev/null || true
	else
		# Update the statefile to add new symlinks (if any), which need to be
		# cleaned up on purge. Also remove old symlinks.
		systemctl update-state 'st2scheduler.service' >/dev/null || true
	fi
fi
# End automatically added section
# Automatically added by dh_systemd_start/12.10ubuntu1
if [ "$1" = "configure" ] || [ "$1" = "abort-upgrade" ] || [ "$1" = "abort-deconfigure" ] || [ "$1" = "abort-remove" ] ; then
	if [ -d /run/systemd/system ]; then
		systemctl --system daemon-reload >/dev/null || true
		if [ -n "$2" ]; then
			_dh_action=restart
		else
			_dh_action=start
		fi
		deb-systemd-invoke $_dh_action 'st2actionrunner.service' 'st2api.service' 'st2auth.service' 'st2garbagecollector.service' 'st2notifier.service' 'st2rulesengine.service' 'st2scheduler.service' 'st2sensorcontainer.service' 'st2stream.service' 'st2timersengine.service' 'st2workflowengine.service' >/dev/null || true
	fi
fi
# End automatically added section
}

prerm() {
# Automatically added by dh_systemd_start/12.10ubuntu1
if [ -d /run/systemd/system ] && [ "$1" = remove ]; then
	systemctl stop 'st2actionrunner.service' 'st2api.service' 'st2auth.service' 'st2garbagecollector.service' 'st2notifier.service' 'st2rulesengine.service' 'st2scheduler.service' 'st2sensorcontainer.service' 'st2stream.service' 'st2timersengine.service' 'st2workflowengine.service' >/dev/null || true
fi
# End automatically added section

# Automatically added by dh_python2:
# dh-virtualenv prerm autoscript
dh_venv_install_dir='/opt/stackstorm/st2'
dh_venv_package='st2'

# set to empty to enable verbose output
test "${DH_VERBOSE:-0}" = "1" && DH_VENV_DEBUG="" || DH_VENV_DEBUG=:
$DH_VENV_DEBUG set -x

case "$1" in
    remove|deconfigure)
        $DH_VENV_DEBUG echo "$0 $1 called with $# args:" "$@"
        rm -f "${dh_venv_install_dir:-/should_be_an_arg}/bin"/*,orig >/dev/null 2>&1 || true
        rm -f "${dh_venv_install_dir:-/should_be_an_arg}/lib"/python*/__pycache__/*.pyc >/dev/null 2>&1 || true
        ;;

    upgrade|failed-upgrade)
        $DH_VENV_DEBUG echo "$0 $1 called with $# args:" "$@"
        ;;

    *)
        #echo >&2 "ERROR:" $(basename "$0") "called with unknown argument '$1'"
        #exit 1
        ;;
esac

$DH_VENV_DEBUG set +x
# END dh-virtualenv prerm autoscript

# End automatically added section
}

postrm() {
# summary of how this script can be called:
#        * <postrm> `remove'
#        * <postrm> `purge'
#        * <old-postrm> `upgrade' <new-version>
#        * <new-postrm> `failed-upgrade' <old-version>
#        * <new-postrm> `abort-install'
#        * <new-postrm> `abort-install' <old-version>
#        * <new-postrm> `abort-upgrade' <old-version>
#        * <disappearer's-postrm> `disappear' <overwriter>
#          <overwriter-version>
# for details, see http://www.debian.org/doc/debian-policy/ or
# the debian-policy package

## Save st2 logrotate config on remove, but wipe it out on purge.
preserve_logrotate() {
  if [ "$1" = remove ]; then
    [ -f /etc/logrotate.d/st2 ] && mv /etc/logrotate.d/st2-pkgsaved.disabled 1>/dev/null 2>&1 || :
  elif [ "$1" = purge ]; then
    rm -f /etc/logrotate.d/st2-pkgsaved.disabled 1>/dev/null 2>&1 || :
    # Clean up other StackStorm related configs and directories
    rm -rf /etc/st2 1>/dev/null 2>&1 || :
    rm -rf /opt/stackstorm 1>/dev/null 2>&1 || :
    rm -rf /root/.st2 1>/dev/null 2>&1 || :
    rm -rf /var/log/st2 1>/dev/null 2>&1 || :
    rm -f /etc/sudoers.d/st2 1>/dev/null 2>&1 || :
  fi
}

case "$1" in
    remove|purge)
      preserve_logrotate "$1"
    ;;
    upgrade|failed-upgrade|abort-install|abort-upgrade|disappear)
    ;;
    *)
        echo "postrm called with unknown argument \`$1'" >&2
        exit 1
    ;;
esac

# dh_installdeb will replace this with shell code automatically
# generated by other debhelper scripts.

# Automatically added by dh_systemd_start/12.10ubuntu1
if [ -d /run/systemd/system ]; then
	systemctl --system daemon-reload >/dev/null || true
fi
# End automatically added section
# Automatically added by dh_systemd_enable/12.10ubuntu1
if [ "$1" = "remove" ]; then
	if [ -x "/usr/bin/systemctl" ]; then
		systemctl mask 'st2scheduler.service' >/dev/null || true
	fi
fi

if [ "$1" = "purge" ]; then
	if [ -x "/usr/bin/systemctl" ]; then
		systemctl purge 'st2scheduler.service' >/dev/null || true
		systemctl unmask 'st2scheduler.service' >/dev/null || true
	fi
fi
# End automatically added section
# Automatically added by dh_systemd_enable/12.10ubuntu1
if [ "$1" = "remove" ]; then
	if [ -x "/usr/bin/systemctl" ]; then
		systemctl mask 'st2workflowengine.service' >/dev/null || true
	fi
fi

if [ "$1" = "purge" ]; then
	if [ -x "/usr/bin/systemctl" ]; then
		systemctl purge 'st2workflowengine.service' >/dev/null || true
		systemctl unmask 'st2workflowengine.service' >/dev/null || true
	fi
fi
# End automatically added section
# Automatically added by dh_systemd_enable/12.10ubuntu1
if [ "$1" = "remove" ]; then
	if [ -x "/usr/bin/systemctl" ]; then
		systemctl mask 'st2timersengine.service' >/dev/null || true
	fi
fi

if [ "$1" = "purge" ]; then
	if [ -x "/usr/bin/systemctl" ]; then
		systemctl purge 'st2timersengine.service' >/dev/null || true
		systemctl unmask 'st2timersengine.service' >/dev/null || true
	fi
fi
# End automatically added section
# Automatically added by dh_systemd_enable/12.10ubuntu1
if [ "$1" = "remove" ]; then
	if [ -x "/usr/bin/systemctl" ]; then
		systemctl mask 'st2garbagecollector.service' >/dev/null || true
	fi
fi

if [ "$1" = "purge" ]; then
	if [ -x "/usr/bin/systemctl" ]; then
		systemctl purge 'st2garbagecollector.service' >/dev/null || true
		systemctl unmask 'st2garbagecollector.service' >/dev/null || true
	fi
fi
# End automatically added section
# Automatically added by dh_systemd_enable/12.10ubuntu1
if [ "$1" = "remove" ]; then
	if [ -x "/usr/bin/systemctl" ]; then
		systemctl mask 'st2sensorcontainer.service' >/dev/null || true
	fi
fi

if [ "$1" = "purge" ]; then
	if [ -x "/usr/bin/systemctl" ]; then
		systemctl purge 'st2sensorcontainer.service' >/dev/null || true
		systemctl unmask 'st2sensorcontainer.service' >/dev/null || true
	fi
fi
# End automatically added section
# Automatically added by dh_systemd_enable/12.10ubuntu1
if [ "$1" = "remove" ]; then
	if [ -x "/usr/bin/systemctl" ]; then
		systemctl mask 'st2rulesengine.service' >/dev/null || true
	fi
fi

if [ "$1" = "purge" ]; then
	if [ -x "/usr/bin/systemctl" ]; then
		systemctl purge 'st2rulesengine.service' >/dev/null || true
		systemctl unmask 'st2rulesengine.service' >/dev/null || true
	fi
fi
# End automatically added section
# Automatically added by dh_systemd_enable/12.10ubuntu1
if [ "$1" = "remove" ]; then
	if [ -x "/usr/bin/systemctl" ]; then
		systemctl mask 'st2notifier.service' >/dev/null || true
	fi
fi

if [ "$1" = "purge" ]; then
	if [ -x "/usr/bin/systemctl" ]; then
		systemctl purge 'st2notifier.service' >/dev/null || true
		systemctl unmask 'st2notifier.service' >/dev/null || true
	fi
fi
# End automatically added section
# Automatically added by dh_systemd_enable/12.10ubuntu1
if [ "$1" = "remove" ]; then
	if [ -x "/usr/bin/systemctl" ]; then
		systemctl mask 'st2auth.service' >/dev/null || true
	fi
fi

if [ "$1" = "purge" ]; then
	if [ -x "/usr/bin/systemctl" ]; then
		systemctl purge 'st2auth.service' >/dev/null || true
		systemctl unmask 'st2auth.service' >/dev/null || true
	fi
fi
# End automatically added section
# Automatically added by dh_systemd_enable/12.10ubuntu1
if [ "$1" = "remove" ]; then
	if [ -x "/usr/bin/systemctl" ]; then
		systemctl mask 'st2stream.service' >/dev/null || true
	fi
fi

if [ "$1" = "purge" ]; then
	if [ -x "/usr/bin/systemctl" ]; then
		systemctl purge 'st2stream.service' >/dev/null || true
		systemctl unmask 'st2stream.service' >/dev/null || true
	fi
fi
# End automatically added section
# Automatically added by dh_systemd_enable/12.10ubuntu1
if [ "$1" = "remove" ]; then
	if [ -x "/usr/bin/systemctl" ]; then
		systemctl mask 'st2api.service' >/dev/null || true
	fi
fi

if [ "$1" = "purge" ]; then
	if [ -x "/usr/bin/systemctl" ]; then
		systemctl purge 'st2api.service' >/dev/null || true
		systemctl unmask 'st2api.service' >/dev/null || true
	fi
fi
# End automatically added section
# Automatically added by dh_systemd_enable/12.10ubuntu1
if [ "$1" = "remove" ]; then
	if [ -x "/usr/bin/systemctl" ]; then
		systemctl mask 'st2actionrunner.service' >/dev/null || true
	fi
fi

if [ "$1" = "purge" ]; then
	if [ -x "/usr/bin/systemctl" ]; then
		systemctl purge 'st2actionrunner.service' >/dev/null || true
		systemctl unmask 'st2actionrunner.service' >/dev/null || true
	fi
fi
# End automatically added section
}

